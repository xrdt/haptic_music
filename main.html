<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="css/general.css"/>
<script type="text/javascript" src="js/dist/paper-full.js"></script>
<!--
<script type="text/javascript" src="js/fireworks.js/script/fireworks.js"></script>
<script type="text/javascript" src="js/firework_basic.js"></script>
<script type="text/javascript" src="js/ripple_basic.js"></script>
<script type="text/javascript" src="js/wormhole.js"></script>
-->
<script type="text/javascript" src="js/greensock-js/src/minified/TweenLite.min.js"></script>
<script type="text/javascript" src="js/greensock-js/src/minified/plugins/CSSPlugin.min.js"></script>
<script type="text/javascript" src="js/greensock-js/src/minified/TimelineMax.min.js"></script>
<script type="text/javascript" src="js/greensock-js/src/minified/TweenMax.min.js"></script>
<script type="text/paperscript" canvas = "myCanvas">
var Objects = [];
// TODO change to dynamic resizing
function rect_rotate() {
    this.group = new Group();
    this.key = 'a'
    this.initTime = null;
    this.updateTime = null;
}

function circle_stationary() {
    this.group = new Group();
    this.key = 'd'
    this.initTime = null;
    this.updateTime = null;
}

function falling_circle() {
  this.group = new Group();
  this.key = 's';
  this.initTime = null;
  this.updateTime = null;
}

function fireworks() {
  this.group = new Group();
  this.key = 's';
  this.initTime = null;
  this.updateTime = null;
}

// Factory for polygons
function Polygon(position, radius, color, sides,
                 lightness_in, strokeWidth,
                 shadowBlur, speed, scale, to_scale, h_0) {
    // sides is an array of integers
    var subs = 3;

    // Some functions require a scaling factor for
    // animation duration
    this.to_scale = to_scale;
    this.scale = scale;
    this.radius = radius;
    this.sides = randomIndex(sides);
    this.polygon = new Path.RegularPolygon(position, this.sides, radius);
    this.paths = [];

    for (var i = 0; i < subs; i++) {
        var h = new Path.RegularPolygon(position, this.sides, h_0);

        if (i === 0) {
            h.strokeColor = color;
        }
        else {
            h.strokeColor = new Color({
                hue:color.hue,
                saturation:color.saturation,
                lightness:lightness_in,
                alpha:1
            });
        }

        h.strokeWidth = strokeWidth;
        h.shadowBlur = shadowBlur;
        h.shadowColor = h.strokeColor;

        this.paths.push(h);
    }

    this.color = this.paths[subs - 1].strokeColor;

    this.speed = speed;
}

Polygon.prototype = {
    animate:function() {
        var tl = new TimelineMax({
            onComplete:function() {
                this.paths.forEach(function(p) {
                    p.remove();
                });
            },
            onCompleteScope:this
        });

        var duration = this.radius / this.speed,
            offset = 0,
            ease = Cubic.easeOut;

        this.paths.forEach(function(h) {
            var from, to;

            for (var i = 0; i < h.segments.length; i++) {
                from = h.segments[i].point;
                to = this.polygon.segments[i].point*this.to_scale;

                tl.to(from, duration*this.scale, {x:to.x, y:to.y, ease:ease}, offset);
                tl.to(h, duration*this.scale, {strokeWidth:0, ease:ease}, offset);
            }

            offset += 0.2;

        }, this);

        return tl;
    }
};
// Factory for lines
function Line(start, endpoint, angle, length, color,
              speed, from, easeFrom, easeTo,
              scale_to, scale_from, end_scale,
              isWormhole, isConstellation) {
    this.start = start;
    this.endpoint = endpoint;
    this.end = new Point();
    this.isWormhole = isWormhole;
    this.isConstellation = isConstellation;

    this.end.setAngle(angle);
    this.end.setLength(length);
    this.end += this.start;

    this.easeFrom = easeFrom;
    this.easeTo = easeTo;
    this.scale_to = scale_to;
    this.scale_from = scale_from;
    this.end_scale = end_scale;

    this.path = new Path();
    if (this.isConstellation) {
        this.path.add(this.start, this.endpoint);
    } else {
        this.path.add(this.start, this.end);
    }
    this.color = this.path.strokeColor = color;
    this.path.visible = false;
    this.path.strokeWidth = 2;
    this.path.strokeCap = 'round';
    this.path.shadowBlur = 32;
    this.path.shadowColor = this.color;

    this.speed = speed;

    this.from = from;
}

Line.prototype = {
    animate:function() {
        var tl = new TimelineMax({
            onStart:function() {
                this.path.visible = true;
            },
            onStartScope:this,
            onComplete:function() {
                if(!this.isConstellation)
                {
                    this.path.remove();
                }
            },
            onCompleteScope:this
        });

        var startPoint = this.path.segments[0].point;

        if (this.isConstellation) {
            endPoint = this.path.segments[1].point;
        } else {
            endPoint = this.path.segments[1].point * this.end_scale;
        }

        var duration = this.path.length / this.speed;

        if (this.from == true && !this.isWormhole) {
            tl.from(endPoint, duration*this.scale_from, {x:startPoint.x, y:startPoint.y, ease:this.easeFrom});
        }
        if (this.isWormhole)
        {
            tl.from(endPoint, duration*this.scale_from, {x:endPoint.x, y:endPoint.y, ease:this.easeFrom});
        }

        /*if (this.isConstellation)
        {
            tl.to(startPoint, duration*this.scale_to, {x:startPoint.x, y:startPoint.y, ease:this.easeTo}, '-=0.5');
        }
        else
        {*/
            tl.to(startPoint, duration*this.scale_to, {x:endPoint.x, y:endPoint.y, ease:this.easeTo}, '-=0.5');
        //}

        return tl;
    }
};

function createFireworkBasic() {
    var tl = new TimelineMax();

    var startPoint = new Point(view.size.width * Math.random(), view.size.height),
        angle = 270,
        length = view.size.height * 0.5,
        size = view.size.height * .06,
        color = getRandomColor();

    var ease = Cubic;
    var trail = new Line(startPoint, 0, angle, length, color,
                         250, false, null, null, 1, 0, 1, false, false),
        hex = new Polygon(trail.end, size, color, [8, 10, 12], .5, 24, 0, 125, 1, 1, 1);

    tl.add(hex.animate(), 'trailDone');

    for (var i = 0; i < hex.sides; i++) {

        var point = hex.polygon.segments[i].point,
            localPoint = point - hex.polygon.position;

        var spark = new Line(trail.end, 0, localPoint.angle, size * 1.5, color, 250, false, null, null, 1, 0, 1, false, false);

        tl.add(spark.animate(), 'trailDone');
    }

    return tl;
}

function createRippleBasic() {
    var tl = new TimelineMax();

    var startPoint = new Point(view.size.width*(Math.random()*.75), view.size.height*(Math.random()*.75)),
        size = view.size.height*.20,
        color = getRandomColor();

    var hex = new Polygon(startPoint, size, color, [4, 6, 8], .2, 36, 32, 200, 1, 1, 0);

    tl.add(hex.animate(), 'trailDone');

    for (var i = 0; i < hex.sides; i++) {
        var point = hex.polygon.segments[i].point,
            localPoint = point - hex.polygon.position;
    }

    return tl;
}

function createWormhole() {
    var tl = new TimelineMax();

    var startPoint = new Point(view.size.width * Math.random(), view.size.height),
        angle = 270,
        length = view.size.height * 0.5,
        size = randomRange(32, 64),
        color = getRandomColor();

    var ease = Cubic;
    var trail = new Line(startPoint, 0, angle, length, color, 500, true, ease.easeInOut, ease.easeOut, 3, .25, 50/100, true, false),
        hex = new Polygon(trail.end, size, color, [8, 10, 12], .7, 24, 64, 200, 3, .5, 0);

    tl.add(hex.animate(), 'trailDone');

    for (var i = 0; i < hex.sides; i++) {

        var point = hex.polygon.segments[i].point,
            localPoint = point - hex.polygon.position;

        var spark = new Line(trail.end, 0, localPoint.angle, size * 2, color, 500, true, ease.easeInOut, ease.easeOut, 3, .25, 0.5, true, false);

        tl.add(spark.animate(), 'trailDone');
    }

    return tl;
}

function createSparksBottom() {
  var tl = new TimelineMax();

  var startPoint = new Point(view.size.width + 1, view.size.height * Math.random() * .5 + .5 * view.size.height),
    angle = 180,
    length = view.size.width + 1.5,
    color = getRandomColor();

    var ease = Cubic;
  var trail1 = new Line(startPoint, 0, angle, length, color, 250, true, ease.easeInOut, ease.easeOut, .1, .05, 1, false, false);

  tl.add(trail1.animate());
  tl.add('trailDone');

  return tl;
}

function createSparksTop() {
  var tl = new TimelineMax();

  var startPoint = new Point(-1, view.size.height * Math.random() * .5),
    angle = 0,
    length = view.size.width + 1.5,
    color = getRandomColor();

    var ease = Cubic;
  var trail2 = new Line(startPoint, 0, angle, length, color, 250, true, ease.easeInOut, ease.easeOut, .1, .05, 1, false, false);

  tl.add(trail2.animate());
  tl.add('trailDone');

  return tl;
}

function createConstellation(startPositions) {
  var circles = [];
  for(var j = 0; j < 7; j++){
    var circle = new Path.Circle(startPositions[j], 5);
    circle.fillColor = getRandomColor();
    circles.push(circle);
  }
  return circles;
}

// Change to be dynamic
function createLineConstellation(tl1, startPositions){
  var tl = tl1;
  var trails = [];

  var color = getRandomColor();
  for(var i = 0; i < 7; i++)
  {
    var startPoint = startPositions[i];
    var endPoint;
    if (i<6)
    {
      endPoint = startPositions[i+1];
    }
    else
    {
      endPoint = startPositions[3];
    }
  }

  for(var i = 0; i< 7;i++){
    var startPoint = startPositions[i];
    if (i<6)
    {
      var endPoint = startPositions[i+1];
    }
    else
    {
      var endPoint = startPositions[3];
    }

    var ease = Cubic;
    var trail = new Line(startPoint, endPoint, 0, 0, color, 250, true, ease.easeInOut, ease.easeOut, .5, .5, 1, false, true);
    trails.push(trail);
  }

  for(var j = 0; j < 7; j++){
      tl.add(trails[j].animate());
      tl.add('trailDone');
  }
  return [tl, trails];
}

////////////
// UPDATE
////////////



paper.install(window);

// Create a centered text item at the center of the view:
var text = new PointText({
	point: view.center,
	content: 'Click here to focus and then press some keys.',
	justification: 'center',
	fontSize: 15
});

function onKeyUp(event) {
	// When a key is pressed, set the content of the text item:
	text.content = 'The ' + event.key + ' key was released!';
}


function onFrame(event) {
    for (var ix = 0; ix < Objects.length; ix++) {
        var child = Objects[ix];
        child.updateTime = performance.now();
        if (child.key == 's') {
            if (child.group.hasChildren()) {
                child.group.firstChild.position.y += 10;
                child.group.firstChild.position.x += 10;
            }
            if (child.updateTime - child.initTime >= 1000) {
                child.group.removeChildren(0, 1);
                Objects.splice(ix, 1);
            }
        } else {
            if (child.updateTime - child.initTime >= 1000) {
                child.group.removeChildren(0, 1);
                Objects.splice(ix, 1);
            } else if (child.group.hasChildren()) {
                child.group.firstChild.rotate(3);
            }
        }
    }
}


function onKeyDown(event) {
	// When a key is released, set the content of the text item:
	text.content = 'The ' + event.key + ' key was pressed!';

	if (event.key == 'a') {
      var cannonUrl = "resources/audio/cannon.wav";
	  var audio = new Audio(cannonUrl);
	  audio.play();

      var rotate_rect = new rect_rotate();
      rotate_rect.group.addChild(new Path.Rectangle([30, 30], [90, 40]));
      rotate_rect.group.firstChild.strokeColor = 'red';
      rotate_rect.initTime = performance.now();
      Objects.push(rotate_rect);
    }
	if (event.key == 'd') {
      var cannonBig = "resources/audio/cannonBig.wav";
	  var audio = new Audio(cannonBig);
	  audio.play();

      var standing_circle = new circle_stationary();
      standing_circle.group.addChild(new Path.Circle([30, 30], 30));
      standing_circle.group.firstChild.strokeColor = 'green';
      standing_circle.initTime = performance.now();
      Objects.push(standing_circle);
    }
	if (event.key == 's') {
      var drums1 = "resources/audio/drums1.mp4";
	  var audio = new Audio(drums1);
	  audio.play();

      var falling = new falling_circle();
      falling.group.addChild(new Path.Circle([0, 0], [10, 10]));
      falling.group.firstChild.position = [0, 0];
      falling.group.firstChild.strokeColor = 'blue';
      falling.group.firstChild.fillColor = 'black';
      falling.initTime = performance.now();
      Objects.push(falling);
    }
	if (event.key == 'f') {
      var strings1 = "resources/audio/strings1.mp4";
	  var audio = new Audio(strings1);
	  audio.play();
	  createFireworkBasic();
    }
	if (event.key == 'r') {
      var synth1 = "resources/audio/synth1.mp4";
	  var audio = new Audio(synth1);
	  audio.play();
	  createWormhole();
    }
	if (event.key == 'g') {
      var strings2Url = "resources/audio/strings2.mp4";
	  var audio = new Audio(strings2Url);
	  audio.play();
	  var startPositions = [];
      var p1 = new Point(150, 150);
      var p2 = new Point(150+100, 150-50);
      var p3 = new Point(150+200, 150+0);
      var p4 = new Point(150+300, 150+0);
      var p5 = new Point(150+350, 150+200);
      var p6 = new Point(150+550, 150+200);
      var p7 = new Point(150+600, 150+0);
      startPositions.push(p1);
      startPositions.push(p2);
      startPositions.push(p3);
      startPositions.push(p4);
      startPositions.push(p5);
      startPositions.push(p6);
      startPositions.push(p7);

      var tl = new TimelineMax();
      var circles = createConstellation(startPositions);
      var varias = createLineConstellation(tl, startPositions);
      var tll = varias[0];
      var trails = varias[1];
      setTimeout(function(){
        for(var i = 0; i < 7; i++){
          trails[i].path.remove();
          circles[i].remove();
        }}, tll.duration()*1000);
    }
	if (event.key == 'h') {
      var static_3 = "resources/audio/static_3.m4a";
	  var audio = new Audio(static_3);
      audio.play();
      var sparksTop = setInterval(createSparksTop, 10);
      var sparksBottom = setInterval(createSparksBottom, 10);

      setTimeout(function() {clearInterval(sparksTop);}, 3000);
      setTimeout(function() {clearInterval(sparksBottom);}, 3000);

    }
	if (event.key == 'j') {
      var xylophone2 = "resources/audio/xylophone2.mp4";
	  var audio = new Audio(xylophone2);
	  audio.play();
	  createRippleBasic();
    }
    if (event.key == 'space') {
        var color = '#'+(Math.random()*0xFFFFFF<<0).toString(16);
        var canvasLayer = document.getElementById("myCanvas");
        canvasLayer.style.background = color;
    }
}

function getRandomColor() {
    return new Color({
        hue:randomRange(0, 100),
        saturation:0.75,
        lightness:0.5
    })
}

function randomIndex(arr) {
    return arr[randomRange(0, arr.length, true)];
}

function randomRange(min, max, floor) {
    var v = min + Math.random() * (max - min);
    floor = floor || false;
    return floor ? (v | 0) : v;
}

</script>
</head>
<body id= test" style="height:100%;margin:0;overflow:hidden;">
  <canvas id="myCanvas" resize="true" style="width:100%;height:100%;"></canvas>
</body>
</html>
